/* 
================================================================================
DATA LAYER - Episode Data Management (RSS-Ready)
================================================================================

üìå FUTURE RSS INTEGRATION:
This file currently loads episodes from static JSON files (season1.json, season2.json).
In the future, these JSON files will be auto-generated by a GitHub Action/Cron job
that fetches data from your RSS feeds and converts them to this format.

The data structure below matches common podcast RSS fields, making the transition seamless.

‚úèÔ∏è TO ADD RSS INTEGRATION LATER:
1. Create a GitHub Action workflow (.github/workflows/update-episodes.yml)
2. Use a script to fetch RSS feed (e.g., from Spotify, YouTube, or custom feed)
3. Parse RSS and generate data/season1.json and data/season2.json
4. Commit changes back to repo automatically

NO CODE CHANGES NEEDED IN THIS FILE - just replace JSON generation method!
================================================================================
*/

// Cache for loaded episodes to avoid redundant fetches
let episodesCache = null;

/**
 * Load episodes from a specific season
 * @param {number} seasonNumber - Season number (1, 2, etc.)
 * @returns {Promise<Array>} Array of episode objects
 */
async function loadSeason(seasonNumber) {
  try {
    const response = await fetch(`data/season${seasonNumber}.json`);
    
    if (!response.ok) {
      console.warn(`Season ${seasonNumber} not found or empty`);
      return [];
    }
    
    const episodes = await response.json();
    
    // Validate data structure
    if (!Array.isArray(episodes)) {
      console.error(`Season ${seasonNumber} data is not an array`);
      return [];
    }
    
    return episodes;
  } catch (error) {
    console.error(`Error loading season ${seasonNumber}:`, error);
    return [];
  }
}

/**
 * Load all episodes from all seasons and merge them
 * @returns {Promise<Array>} Array of all episodes, sorted by date (newest first)
 * 
 * ‚úèÔ∏è TO ADD MORE SEASONS: Just add more loadSeason(N) calls to the array
 */
async function loadAllEpisodes() {
  // Return cached data if available
  if (episodesCache) {
    return episodesCache;
  }
  
  try {
    // Load all seasons in parallel for better performance
    const [season1, season2] = await Promise.all([
      loadSeason(1),
      loadSeason(2)
      // ‚úèÔ∏è ADD MORE SEASONS HERE: loadSeason(3), loadSeason(4), etc.
    ]);
    
    // Merge all seasons
    const allEpisodes = [...season1, ...season2];
    
    // Sort by date (newest first)
    allEpisodes.sort((a, b) => {
      const dateA = new Date(a.date);
      const dateB = new Date(b.date);
      return dateB - dateA; // Descending order
    });
    
    // Cache the result
    episodesCache = allEpisodes;
    
    return allEpisodes;
  } catch (error) {
    console.error('Error loading all episodes:', error);
    return [];
  }
}

/**
 * Get a single episode by ID
 * @param {string} episodeId - Episode ID (e.g., "s2e12")
 * @returns {Promise<Object|null>} Episode object or null if not found
 */
async function getEpisodeById(episodeId) {
  const allEpisodes = await loadAllEpisodes();
  return allEpisodes.find(ep => ep.id === episodeId) || null;
}

/**
 * Filter episodes by season
 * @param {Array} episodes - Array of episodes
 * @param {number|string} season - Season number or "all"
 * @returns {Array} Filtered episodes
 */
function filterBySeason(episodes, season) {
  if (season === 'all' || season === null) {
    return episodes;
  }
  
  const seasonNum = parseInt(season);
  return episodes.filter(ep => ep.season === seasonNum);
}

/**
 * Search episodes by title or description
 * @param {Array} episodes - Array of episodes
 * @param {string} query - Search query
 * @returns {Array} Filtered episodes
 */
function searchEpisodes(episodes, query) {
  if (!query || query.trim() === '') {
    return episodes;
  }
  
  const lowerQuery = query.toLowerCase().trim();
  
  return episodes.filter(ep => {
    const titleMatch = ep.title.toLowerCase().includes(lowerQuery);
    const descMatch = ep.description && ep.description.toLowerCase().includes(lowerQuery);
    return titleMatch || descMatch;
  });
}

/**
 * Format date to readable format (Macedonian locale)
 * @param {string} dateString - ISO date string
 * @returns {string} Formatted date
 */
function formatDate(dateString) {
  const date = new Date(dateString);
  
  // Check if date is valid
  if (isNaN(date.getTime())) {
    return dateString;
  }
  
  // Format: 15 —ò–∞–Ω—É–∞—Ä–∏ 2026
  const options = { day: 'numeric', month: 'long', year: 'numeric' };
  return date.toLocaleDateString('mk-MK', options);
}

/**
 * Extract YouTube video ID from URL
 * @param {string} url - YouTube URL
 * @returns {string|null} Video ID or null
 */
function getYouTubeId(url) {
  if (!url) return null;
  
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
  const match = url.match(regExp);
  
  return (match && match[2].length === 11) ? match[2] : null;
}

/**
 * Extract Spotify episode ID from URL
 * @param {string} url - Spotify URL
 * @returns {string|null} Episode ID or null
 */
function getSpotifyId(url) {
  if (!url) return null;
  
  const match = url.match(/episode\/([a-zA-Z0-9]+)/);
  return match ? match[1] : null;
}

/* 
================================================================================
üîÆ FUTURE RSS INTEGRATION PLACEHOLDER
================================================================================

When you're ready to integrate RSS feeds, you'll create a separate script
(e.g., scripts/generate-json-from-rss.js) that will:

1. Fetch RSS feed from your podcast host (Spotify, YouTube, custom feed)
2. Parse RSS XML
3. Convert to JSON format matching the structure below:

EXPECTED JSON STRUCTURE (already used in this app):
{
  "id": "s2e12",           // Unique ID (season + episode)
  "season": 2,             // Season number
  "episode": 12,           // Episode number
  "title": "EP 12 ‚Äì Guest Name ‚Äì Topic",
  "date": "2026-01-01",    // ISO date format
  "youtube": "https://www.youtube.com/watch?v=XXXX",
  "spotify": "https://open.spotify.com/episode/XXXX",
  "thumbnail": "https://img.youtube.com/vi/XXXX/hqdefault.jpg",
  "description": "Show notes text..."
}

4. Save to data/season1.json and data/season2.json
5. Run this as a GitHub Action on a schedule (e.g., every 6 hours)

EXAMPLE GITHUB ACTION WORKFLOW:
name: Update Episodes from RSS
on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:         # Manual trigger
jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm install rss-parser
      - run: node scripts/generate-json-from-rss.js
      - uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: "Auto-update episodes from RSS"

NO CHANGES NEEDED TO THIS FILE - it will automatically work with RSS-generated JSON!
================================================================================
*/
